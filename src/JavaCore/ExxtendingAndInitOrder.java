package JavaCore;


/* package com.javarush.task.task15.task1526;
Дебаг, дебаг, и еще раз дебаг

Дебаг, дебаг, и еще раз дебаг
Программа выводит 0 9, а должна — 6 9. Найди одну(!) ошибку и исправь ее.
Используй дебаг. Для этого поставь breakpoint-ы (Ctrl+F8), потом зайди в меню Run -> Debug.
F9 - выполнение кода до следующего breakpoint-а.
F8 - переход к следующей строке кода.


Requirements:
1. Программа должна выводить данные на экран.
2. Вывод на экран должен соответствовать условию задачи.
3. У метода initialize() в классе A должен быть правильный модификатор доступа.
4. Программа не должна считывать данные с клавиатуры.
*/

public class ExxtendingAndInitOrder {
    public static void main(String[] args) {
        new B(6);
    }

    public static class A {
        private int f1 = 7;

        public A(int f1) {
            this.f1 = f1;
            initialize();
        }

        protected void initialize() {
            System.out.println(f1);
        }
    }

    public static class B extends A {
        protected int f1 = 3;

        public B(int f1) {
            super(f1);
            this.f1 += f1;
            initialize();
        }

        protected void initialize() {
            System.out.println(f1);
        }
    }
}

/*Копирую коммент от Антона Никольского 7 янв 2018
Ключевой вопрос этой задачи: метод initialize() в конструкторе класса А вызывается как "initialize() класса А" или "initialize() класса В"? Для ответа надо знать следующее:

Порядок обработки кода:
1) Компилятор преобразует джава-код в байт-код (программа еще не выполняется)
2) Джава-машина выполняет байт-код (собственно выполнение программы)

Порядок инициализации классов и новых объектов:
1) Статические элементы
2) Нестатические переменные родителя
3) Конструктор родителя
4) Нестатич-ие переменные наследника
5) Конструктор наследника

В объекте класса В создается 2 переменных f1.

а) Ситуация до исправления модификатора.
При вызове new B(6) сначала происходит вызов конструктора класса А, а переменная f1 в коде класса В еще не инициализировалась и равна 0. В конструкторе класса А происходит вызов метода initialize(). Поскольку этот метод может быть переопределен в классах-наследниках, то компилятор не привязывает вызов этого метода к "initialize() класса А", а отдает этот вопрос на решение джава-машины. Джава-машина видит, что метод вызван из "объекта класса В" (потому как new B(6)), и соответственно вызывает "initialize() класса В". Однако переменная f1 в коде класса В еще не успела инициализоваться (см. порядок инициализации), поэтому выводится 0.

б) Ситуация после исправления модификатора.
Все то же самое, но теперь компилятор считает, что приватный метод "initialize() класса А" переопределяться не будет. Поэтому он жестко привязывает вызов метода initialize() в конструкторе А к "initialize() класса А" еще ДО выполнения программы. И джава-машине ничего не остается как вызывать там метод initialize() именно класса А, а не класса В.

В интернете где-то есть по этому поводу информация, что в джаве (в отличие от С++) для приватных и финальных методов применяется раннее связывание (на уровне компилятора до выполнения программы), а для "обычных" методов - позднее связывание (на уровне джава-машины во время выполнения).*/
